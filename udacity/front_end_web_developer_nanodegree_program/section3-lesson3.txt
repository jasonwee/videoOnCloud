

3.3.1 Introduction
---------------------------------------
Need to Know
To be successful in this section, there are a couple of things from the previous section that you need to know. You need to have a solid grasp of selecting DOM elements using:

* document.getElementById()
* document.querySelector()

Also, remember the Node Interface and the Element interface we went over in the previous section? Understanding how an interface determines the properties and methods for an element and understanding how to research an interface's properties and methods will be vital in this lesson.

If you get stuck, just jump back to the previous section that's giving you a bit of trouble.

Project Repository
Throughout this course, you'll learn skills and techniques to access and modify page content. There's no better way to demonstrate these skills than through trying them out on a real website! So I've created a copy of just the Udacity homepage on GitHub - https://github.com/udacity/course-JS-and-the-DOM. You can call this as a remote repository. Now, you can do either of the following:

* Clone the remote repository to your local machine so that you can follow along. To clone, you can use git clone https://github.com/udacity/course-JS-and-the-DOM command on your terminal. When you clone a remote repository, you get an identical copy locally, where you can make desired changes.
* Fork the remote repository to your own online account. When you fork a remote repository, a new duplicate copy of the remote repository is created in your account.

A detailed course on Git & GitHub is available in the extracurricular section of this nano-degree.

Check off tasks as you complete them
* I have cloned the project
* I understand that this project is just the index page of the Udacity site.
* I understand that the code in this repo is not representative of how Udacity builds its site. ;-)



3.3.2 Update Existing Page Content
---------------------------------------
Let's jump right into it. Open up the project in your browser. There's only one HTML file (index.html) so this is what it should look like after you open it:

💡Project Code 💡
Instructions and a walkthrough of the project were in the previous section. You can clone the project from the GitHub link below. Look back at the previous section to see detailed information about the project and a walkthrough video.

Project repository: https://github.com/udacity/course-JS-and-the-DOM

The `index.html` serves as a starter template for you to get started. There might be a slight mismatch between the actual content of `index.html` file downloaded from GitHub vs. the one shown in the demo. However, the mismatch would not block you from practicing the classroom instructions.

Write the DOM code necessary to select the first element with class: card

document.querySelector('.card')

Let's store the first .card element in a variable for easy access:

const nanodegreeCard = document.querySelector('.card');
Now that we've stored the first card element in the nanodegreeCard variable, we can use nanodegreeCard to refer to this element instead of having to use document.querySelector('.card') to select the element every time we need access to it.


An Element's Inner HTML

Every element inherits properties and methods from the Element Interface (remember this from the previous lesson!). This means that every element has an .innerHTML property. This property, as it's rightly named, represents the markup of the element's content. We can use this property to:

* get an element's (and all of its descendants!) HTML content
* set an element's HTML content

Quiz Question
￼
What is .innerHTML?

a property


Quiz Question
￼
What does .innerHTML return?
￼
a string


💡 Innie vs Outie 💡
The .innerHTML property sets or returns the HTML content inside the selected element (i.e. between the tags).

There's also the rarely used .outerHTML property. .outerHTML represents the HTML element itself, as well as its children.

<h1 id="pick-me">Greetings To <span>All</span>!</h1>

const innerResults = document.querySelector('#pick-me').innerHTML;
console.log(innerResults); // logs the string: "Greetings To <span>All</span>!"

const outerResults = document.querySelector('#pick-me').outerHTML;
console.log(outerResults); // logs the string: "<h1 id="pick-me">Greetings To <span>All</span>!</h1>"

An Element's Text Content
So .innerHTML will get/set an element's HTML content. If we just want the text content, we can use the fantastically named .textContent property!

The .textContent property will:

* set the text content of an element and all its descendants
* return the text content of an element and all its descendants

Let's check it out!

Check out the .textContent's documentation page on MDN: textContent docs

Setting an element's text content is easy, just set it like you would any other property:

nanodegreeCard.textContent = "I will be the updated text for the nanodegreeCard element!";

Quiz Question
￼
<h1 id="test">Ice Cream Flavors</h1>
Given the HTML above, what will be the .textContent value after running this code:

const myElement = document.querySelector('#test');
myElement.textContent = 'The <strong>Greatest</strong> Ice Cream Flavors';

The < strong >Greatest</ strong > Ice Cream Flavors

We just saw that passing text that contains HTML characters to .textContent will not display the content as HTML. Instead, it will still display everything as text - even the HTML characters!

If you'd like to update an element, including its HTML, then you need to use the .innerHTML property:

myElement.textContent = 'The <strong>Greatest</strong> Ice Cream Flavors'; // doesn't work as expected

myElement.innerHTML = 'The <strong>Greatest</strong> Ice Cream Flavors';  // works as expected

An Element's Text Content - Version 2!
We can't close this section out without looking at the .innerText property!

Like the .textContent property, the .innerText property can be used to get/set an element's text content, but there are some important differences between the two properties.

.textContent sets/gets the text content of an element...pretty clear and simple.

.innerText, on the other hand, is a little tricker. Let's see this in action and then we'll discuss it!

As you saw, .innerText will get the visible text of the element. This is an important distinction! If CSS is used to hide any text inside that element, .innerText will not return that text, while .textContent will return it. And it's not just the hiding/showing nature of CSS that .innerText adheres to, .innerText will also honor changes to things like capitalization.

The .textContent property has been a standard for quite a long time. Conversely, .innerText property is a relatively new addition to the HTML specification. It has been around for a while but was not fully supported by all browsers because it was not a part of the HTML specification.

Between .textContent and .innerText, you probably want to use .textContent since that will return all of the text no matter what. Rarely will you actually want only the visible text.

Update Existing Content Recap
In this section, we looked at multiple ways to change page content:

* .innerHTML
* .textContent
* .innerText

We saw that to set HTML content for an element, out of the three properties list above, we can only use .innerHTML. Using .textContent will erroneously include the HTML characters as plain text inside the element.

We also looked at the difference between .textContent and .innerText. .textContent completely ignores any CSS styling and returns all of the element's HTML just as it's listed in the HTML. On the other hand, the .innerText property will take CSS styling into consideration and will return the text that is visibly rendered on the page.

Further Research
* innerHTML on MDN
* textContent on MDN
* innerText on MDN
* Article: The poor, misunderstood innerText
* Article: innertext vs. textcontent
￼

￼
3.3.3 Add New Page Content
---------------------------------------
Quiz Question
￼
You've learned about the document object, the Node Interface, and the Element interface. Where does .createElement() come from?

the document object


What is the URL for the "createElement" page on MDN?

https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement￼


Quiz Question
￼
Which of the following would create a new paragraph element?

document.createElement('p');
￼

As you've already discovered, the .createElement() method is a method on the document object:

// creates and returns a <span> element
document.createElement('span');

// creates and returns an <h3> element
document.createElement('h3');
Here's the .createElement() documentation page on MDN: createElement docs

Adding Content To The Page

You may have noticed that using document.createElement() to create an element didn't actually add that newly created element anywhere on the page! Creating an element...just creates it. It doesn't add it to the DOM. Since the element isn't added to the DOM, it doesn't appear in the page (if you remember, the DOM is the parsed representation of the page). So, now that we can create brand new elements, we need to be able to add them to the DOM so that they'll show up on the page.

We can use the .appendChild() method to add an element to the page! Before we see how this element works, let's quickly define the word "append". There are several different definitions of the word, but I like the wording of the Cambridge Dictionary's the best:

to add something to the end of a piece of writing

definition of the word "append" (source)

Now, to use the .appendChild() method, it needs to be called on another element, not the document object!

// create a brand new <span> element
const newSpan = document.createElement('span');

// select the first (main) heading of the page
const mainHeading = document.querySelector('h1');

// add the <span> element as the last child element of the main heading
mainHeading.appendChild(newSpan);

I like the Cambridge Dictionary's version because it clearly states how the content is added at the end. The .appendChild() method is called on one element, and is passed the element to append. The element that is about to be appended is added as the last child. So, in the example above, the <span> element will appear in the DOM as a child of the <h1>...but it will appear at the end, after all text and any other elements that might be in the <h1>.

Here's the .appendChild() documentation page on MDN: [appendChild docs)(https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)

⚠️ .appendChild() Needs An Element! ⚠️
This is stated above, but I wanted to call this out, specifically. When you're using the .appendChild() method, it must be called on an existing element. To be clear, you can't call this on the document object, so the following will result in an error:

const newSpan = document.createElement('span');

// causes an error
document.appendChild(newSpan);

Creating Text Nodes

Just like you created new elements with the .createElement() method, you can also create new text nodes using the .createTextNode() method. Take a look at the following code that:

* creates a paragraph element
* creates a text node
* appends the text node to the paragraph
* appends the paragraph to the tag

const myPara = document.createElement('p');
const textOfParagraph = document.createTextNode('I am the text for the paragraph!');

myPara.appendChild(textOfParagraph);
document.body.appendChild(myPara);

However, since you already know about the .textContent property, the code below will provide the exact same result:

const myPara = document.createElement('p');

myPara.textContent = 'I am the text for the paragraph!';
document.body.appendChild(myPara);

Therefore, instead of creating a new text node and appending it to an element, it's faster and easier to just update the element's text with the .textContent property.

For more info, check out the documentation: createTextNode() docs

Quiz Question
￼
What happens after running this code?

const mainHeading = document.querySelector('#main-heading');
const otherHeading = document.querySelector('#other-heading');
const excitedText = document.createElement('span');

excitedText.textContent = '!!!';
mainHeading.appendChild(excitedText);
otherHeading.appendChild(excitedText);
Don't guess it, test it! This one might surprise you!
￼
only otherHeading has three exclamation marks

Inserting HTML In Other Locations

By definition, the .appendChild() method will add an element as the last child of the parent element. It's impossible to put it as the first child or anywhere else...it has to be the last child. Wouldn't it be nice if there were a little flexibility in where we could add the child element?

Enter the .insertAdjacentHTML() method! The .insertAdjacentHTML() method has to be called with two arguments:

* the location of the HTML
* the HTML text that is going to be inserted

The first argument to this method will let us insert the new HTML in one of four different locations

* beforebegin – inserts the HTML text as a previous sibling
* afterbegin – inserts the HTML text as the first child
* beforeend – inserts the HTML text as the last child
* afterend – inserts the HTML text as a following sibling

A visual example works best, and MDN's documentation has a fantastic example that I'll modify slightly:

<!-- beforebegin -->
<p>
    <!-- afterbegin -->
    Existing text/HTML content
    <!-- beforeend -->
</p>
<!-- afterend -->

Here's how we'd call .insertAdjacentHTML():

const mainHeading = document.querySelector('#main-heading');
const htmlTextToAdd = '<h2>Skydiving is fun!</h2>';

mainHeading.insertAdjacentHTML('afterend', htmlTextToAdd);

Check out the documentation page for more information: insertAdjacentHTML docs

At 0:22 seconds, the instructor says "... this has to be text, not HTML. If you pass HTML, then that HTML will actually be displayed". There is a correction:

The second argument text of insertAdjacentHTML() method parses the specified text as HTML and inserts the resulting nodes into the DOM tree at a specified position.

Add New Page Content Recap

In this section, we learned how to create new DOM elements and add them to the page. We looked at the following methods:

* .createElement() to create new elements
* .appendChild() to add a child element to a parent element as its last child
* .createTextNode() to create a text node
* .insertAdjacentHTML() to put HTML text anywhere around an element

Some important things to note are:

* if an element already exists in the DOM and this element is passed to .appendChild(), the .appendChild() method will move it rather than duplicating it
* an element's .textContent property is used more often than creating a text node with the .createTextNode() method
* the .insertAdjacentHTML() method's second argument has to be text, you can't pass an element

Further Research
* createElement on MDN
* createTextNode on MDN
* appendChild on MDN
* insertAdjacentHTML on MDN




