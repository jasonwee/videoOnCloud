date start : 05 november 2021


2.1 Introduction
---------------------------------------
The Software Development Life Cycle (SDLC) flows from spec to build, to deploy, from left to right.

In traditional SDLC, security steps are often forgotten about till the very end, when you are ready to deploy. At that point, fixing security flaws will be very expensive, both in terms of absolute effort and cost.

This course is all about baking practical threat modeling and service hardening into your microservices SDLC to ensure security is not forgotten.

Threat modeling is a systemic technique to evaluate security risks and threats that could affect a system.

Important: Threat modeling hypothesizes what could go wrong and forms the basis for reasoning for all the security techniques that you will implement later. Therefore, the threat model needs to be very precise. Later in the course, we will test this hypothesis and confirm which threats actually exist by running scanning tools.

The Shifting-Left Principle and Steps of SDLC


The shifting-left principle refers to incorporating threat modeling and security verifications into the early stages of the software development process once the spec is defined. By shifting left, the threat model is defined early, once the spec exists. Here are the steps in the SDLC with shifting-left (also illustrated in the two diagrams below):

The engineering team iterates on the spec. Tools are run to evaluate and identify security threats and flaws.
The spec is refined and the engineering team proceeds to build.
During the build, automated security tools should be run to verify and provide the engineering team actionable feedback so they can be remediated or accepted as a reasonable risk.
Prior to deployment, tools are re-run to verify the deployment for flaws.
With a running deployment, we should be concerned with all the same steps and ensure we do not forget about security.
Any significant changes to the service should be threat-modeled and security evaluated.
Once we re-enter a build phase, automated verifications should be run again.
The same repeats for the deployment phase. We should verify prior to deployment.
This cycle should repeat itself perpetually until the service is retired.
Specifically, what to threat model and why will be covered in this lesson; the how-to will be covered in the upcoming Docker and Kubernetes hardening lessons.

Introducing STRIDE
In this lesson, we will learn all about STRIDE and apply it to microservices, including Docker and Kubernetes.

STRIDE is a systematic and intentional threat analysis framework using a mnemonic that allows you to consider the primary ways a system can be affected by an attack. It focuses on evaluating threats from an impact perspective.

A Brief History of the STRIDE Framework
STRIDE was developed at Microsoft in the early 2000s.
STRIDE was popularized by Microsoft’s trusted computing push and Adam Showstack in mid the 2000s. Nearly 20 years later, other models have been established, yet STRIDE is still the most relevant high-level threat modeling framework.
New Terms
Threat modeling is a systemic technique to evaluate security risks and threats that could affect a system.
The shifting-left principle refers to incorporating threat modeling and security verifications into the early stages of the software development process once the spec is defined.
STRIDE is a systematic and intentional threat analysis framework using a mnemonic that allows you to consider the primary ways a system can be affected by an attack.



2.2 Lesson Overview
---------------------------------------
We will cover the following topics in this lesson:

We will learn about security and STRIDE fundamentals to establish core terminology
We will evaluate the Docker high-level system abstraction and apply the STRIDE methodology to Docker’s attack surface
We will evaluate the Kubernetes high-level system abstraction and apply the STRIDE methodology to Kubernetes’ attack surface
Lastly, we will evaluate enterprise considerations for how to scale and automate threat modeling as part of an enterprise SDLC



2.3 STRIDE Fundamentals
---------------------------------------
Key Security Concepts
Let's review the following key security concepts, as they are foundational to understanding the STRIDE framework:

Authenticity: This is affected when a non-genuine user poses as a legitimate user. This can be protected with proper authentication.
Integrity: This is affected when a user maliciously tampers with data or a system.
Non-repudiation: This is affected when a change is made that cannot be associated with a known legitimate action. It is the act of denying something happened.
Confidentiality: This is affected when sensitive data is exposed. Data can be exposed while in motion on the network or at rest due to lack of or poor encryption.
Availability: This is affected by system uptime. This can happen as a result of resource starvation during a denial of service attack or lack of rate-limiting on an API.
Authorization: This is affected when the access level (permission) within a system is abused or exceeded.

The STRIDE Framework
STRIDE is a mnemonic - a systematic and intentional threat analysis framework that helps you reason about what could go wrong.

"S" represents Spoofing: This is the act of posing as someone or something for malicious intent, such as disguising the identity of a system administrator. It affects authenticity.
"T" represents Tampering: This is modifying a system for malicious intent, such as modifying system files. It affects integrity.
"R" represents Repudiation: This is the act of denying doing something, such as denying the download of data from a database. It affects non-repudiation.
"I" represents Information Disclosure: This refers to disclosing private or sensitive information, such as dumping stolen credentials on Pastebin. It affects confidentiality.
"D" represents Denial of Service: This refers to affecting the availability of a system, such as overwhelming a system with too much traffic that is not rate-limited. It affects availability.
"E" represents Elevation of Privilege: This refers to escalating your privilege to affect authorization levels.

Summary Table
Threat	Desired Security Property
Spoofing	Authenticity
Tampering	Integrity
Repudiation	Non-repudiation
Information disclosure	Confidentiality
Denial of Service	Availability
Elevation of Privilege	Authorization

Additional Resources
For further reading on STRIDE, please consider the following resources:

STRIDE Methodology
Carnegie Mellon University - Threat Modeling: 12 Available Methods
Books:

Adam Showstack | Threat Modeling: Designing for Security



2.4 Monolithic vs Microservices Security Boundaries
---------------------------------------
Monolithic vs Microservices Security Boundaries
Before we get deeper into threat modeling, let's discuss security boundaries for monolithic and microservices architectures. As a security-trained professional or security engineer, it's vital to provide accurate representations of the application architecture you are evaluating. This is best done using a design document and diagrams. Technical diagrams are often a required component for an architecture security review and will be requested by other engineers and managers reviewing your application architecture design. Technical diagrams show the system as part of the larger landscape and allow your stakeholders to contextualize the design. As microservices are broken down into many smaller service units, it's vital to understand the relationship between all the services.

Without diagrams, it's difficult to explain and reason about your design, collaborate with your colleagues on a project’s motivation and priorities, and discuss considered alternatives. Most importantly, it's hard for your stakeholders to be on the same page regarding the specific implementation and security risk. It's hard to get credit for your work with code alone, as it requires a narrative to explain what you built. Lastly, design docs shape a narrative that can be referenced for performance evaluation, promotion and openly shared across your organization for other engineers to learn from.

Note: We will not teach design doc practices or culture. There are many great reasons to create design docs. It's an everyday practice at the world's leading software companies and something you should learn to implement if you are not already on-board. Take a look at the additional reading for these topics.

We will discuss two architectural design primitives:

One traditional monolithic three-tier architecture (load balancer, web server, database server) with an external caller (Braintree)
A containerized microservices architecture (load balancer, Kubernetes cluster running docker containers, a traditional MySQL server) with an external caller (Braintree)

Traditional Monolithic Three-Tier Architecture
Let's take a look at a traditional monolithic three-tier architecture (load balancer, web server, database server) with an external caller (Braintree).

The system is an e-commerce web application running Nginx to serve traffic over ports 80 and 443.
User traffic hits a load balancer and is directed to the Nginx webserver.
Once on the website, the user browses the CrossFit equipment catalog adding a dumbbell, this calls the SQL database which provides all metadata on the product.

User queries are all handled via single Java application runtime with persistent data queries passed to a SQL database.

The user then checks out which then prompts the single Java application runtime to collect all shopping cart artifacts and passes, assembles the checkout order, and passes the payment card data to Braintree for an authorization code.

Once the authorization code is received the user is passed back to the single Java application runtime to enter their phone number to receive a text when their order ships.

The single Java application runtime then sends the customer a text when their order ships.

All client/server interactions are written to a Syslog cluster. However, since all calls are to a single Java application runtime, it's difficult to trace problems.

The application passes payment card data to a third-party gateway provided by Braintree.

Service Boundaries:

Service boundaries are defined as a logical grouping of services where the service API needs to call other services. The service and security boundaries are often the same.
Security Boundaries:

Security boundaries are defined as the part of the network that has a shared set of controls such as a single subnet that allows communication between all services.
The load balancer and service boundary are the security boundaries as all services except Braintree are on the same network subnet communicating with each other.
Services are aware of each other often using hard-coded credentials or service accounts to authenticate. Trust is assumed as services are implicitly aware of each other.
If we break out the logging and database services to their own subnets, this creates network isolation for those services. From there we can then apply a network access control or firewall rule to restrict traffic between services.

Containerized Microservices Architecture
Let's take a look at a containerized microservices architecture (API-gateway, Kubernetes cluster running multiple containerized services, and a MySQL server for persistent data) with an external caller (Braintree). The system is an e-commerce web application running an edge-API to serve traffic over ports 80 and 443.

User traffic hits a load balancer acting as an api-gateway to the edge-api microservice service that handles user gRPC requests from clients (users).
Once on the website, the user browses the CrossFit equipment catalog adding a dumbbell, this calls the content-api microservice which provides all metadata on the product by calling a persistent data store service.
The user then checks out, which redirects them to the check-out-api microservice, which collects all shopping cart artifacts and passes, assembles the checkout order, and passes the payment card data to Braintree for an authorization code.
Once the authorization code is received, the user is passed to the shipping-api microservice, which provides them the ability to enter their phone number to receive a text when their order ships.
The notification-api microservice then sends the customer a text when their order ships.
All gateway, edge API, and client/microservices interactions are logged to the Grafana cluster running collecting Prometheus to collect Jaeger metrics.

Security Boundaries:

Security trust boundaries are defined into three - gateway boundary, service boundary, cluster boundary
The gateway boundary acts as a central API for all traffic bound to the cluster, often providing rate limiting and traffic routing as a load balancer would.
The service boundary isolates persistent, non-immutable services such as logging and storage services into a single network.
The cluster boundary isolates immutable containerized services running within the cluster.
Cluster services are not implicitly aware of each other and use mutual Transport Layer Security (mTLS) to authenticate. Trust is not implied but rather proven by the service presenting its certificate to authenticate to other services.


The Differences
Let's now highlight some differences:

As you can see, the microservices design clearly breaks up large services into smaller, focused services.
With a monolithic application, a single large application runs the application as a lone runtime developed in one language and released as a single binary.
The security boundaries are redefined with microservices, as each container becomes a security boundary, versus the single webserver as a security boundary.
With microservices, security becomes focused on individualized container deployments and interaction between services. This is often referred to as east to west traffic (left to right). With monolithic applications, it's mostly about north to south traffic (up to down). We will cover isolation and boundaries in more detail in the course.

Further Reading
For further reading on monolithic vs microservices architectures, please consider the following resources:

Design doc culture at Google
Kindness in engineering at Snap
What’s the Difference Between Monolith and Microservices?



2.5 Quiz: STRIDE Fundamentals
---------------------------------------
spoofing
tampering
repudiation
information disclosure
escalation of privilege
denial of service

denying
modifying
availability


2.6 Exercise: Simple Infrastructure Thread Model with STRIDE
---------------------------------------
continuous attack by sending a lot of api requests to the web servers. the idea is to exhaust the web servers resources such that valid api requests no longer able to serve correctly. The goal is to bring down the service by launching this denial of service.

* information disclosure
* denial of service
* Elevation of Privilege


2.7 Solution: Simple Infrastructure Thread Model with STRIDE
---------------------------------------
Environment Diagram
Given the provided description, we created a simple diagram describing the application components and boundaries.



Threat Model Summary
Given the simple infrastructure threat model, let's evaluate what could go wrong with this infrastructure model based on the provided information.

Simple App Threat Model:
1.Provide a profile of potential attackers, including their goals and methods

Malicious attackers may be interested in either disrupting the application or financial gain by stealing user data or modifying pricing in their favor.
2.Given system components and the STRIDE, identify potential threats that may arise.

Here is an example for each aspect of STRIDE.

Spoofing: Single Internet-accessible OpenSUSE leap web server running Nginx to serve traffic over ports 80 (HTTP) and 443 (HTTPS). Traffic is allowed on port 80 (HTTP) is unencrypted. This may allow an attacker to intercept communication between client and server, leading to spoofing of the traffic.
Tampering: The web server is behind a load balancer. Data is stored in a SQL database. Using a load balancer provides security and scalability benefits. However, the application uses a SQL database, which may allow an attacker to pass URL parameters with a SQL injection, leading to tampering by querying data from the SQL database.
Repudiation: If the webserver traffic is spoofed, an attacker could gain control of a user session. This could lead to repudiation for user actions on the application and fraudulent transactions.
Information Disclosure: The application accepts credit cards processed via a third-party gateway provided by Braintree. The application logs all client/server transactions via a Syslog server. While the handling of sensitive payment data occurs by Braintree, the integration may involve log generation and storage that, if miss-configured, may lead to information disclosure of the credit card number. This will provide information to someone not authorized to access it.
Denial of Service: The application is behind a load balancer, which may provide some denial of service protection. However, that's not the dedicated focus for a load balance. Lack of purpose-built rate-limiting or denial of service protection could result in exhausting resources needed to provide the service and lead to an outage.
Elevation of Privilege: An attacker may attempt to abuse a regular user's login to escalate privilege to an administrative login such as admin or administrator. This may lead to the elevation of privilege, allowing them to do something they are not authorized to do.

Review
Through this exercise, we evaluated the threat model for a simple web application. Although all responses will be marked as "correct", I encourage you to compare your response with the solution and think about the differences.

For example, if you had a hard time providing the service and security boundaries in the diagram, that is vital to the threat model. Also, in evaluating this environment against STRIDE, it's important to think about the implications of the provided design. For example, port 80 means traffic is on HTTP, which is non-encrypted and hence subject to man-in-the-middle (spoofing).

While there is no "single right answer", the goal is to understand how to threat model in a systemic and methodical way. It may feel like a big time commitment and slow you down to diagram and evaluate threats before digging into building the system.

Security Engineering is as much a technical discipline as it is a process. The earlier you identify a security problem, the earlier you can understand the practical concerns and define techniques to address them as a functional requirement, just as you would address a spiking P99 page latency for a high traffic e-commerce application.

As we progress through the course and profile attack surfaces for Docker and Kubernetes, our threat models will become far more sophisticated. However, the basic foundation questions will be the same:

What could go wrong?
What are we going to do about it?
How do we know our mitigations are good enough?
Next, we will work to apply the STRIDE methodology to concretely evaluate the Docker primary components.



2.8 Docker Fundamentals
---------------------------------------

Docker Recap
Docker runs on bare-metal infrastructure and on top of the host operating system.

Docker engine consists of Docker daemon and Docker client:

Docker daemon is the engine to manage containers. It runs constantly, listening for calls (instructions from the docker client) to do things.
Docker client interacts with the docker daemon, sending commands such as docker build or docker deploy.
3 Boundaries within the Docker System:
Docker client
Docker host
Docker registry
Here is how these 3 system components interact with each other:

Create a Dockerfile: The Docker client is nearly always where the Dockerfile is created.
Pull the latest image: You nearly always start with a base image by running docker pull. The Docker client makes a remote procedure call (RPC) to the Docker daemon to carry out the command and pull the latest image from the Docker registry in the Docker Hub image store.
Build the image layers: When you run a command such as docker build on your client, the client RPCs to the Docker daemon to build the image layers.
Push the image to the Docker Hub: Once the image is built, you run docker push to commit the image to the Docker Hub image store, again the client RPCs to the Docker daemon to push the image to the Docker Hub.
What Happens When You Provision a Container on the Host?
NOTE: We will assume the container image was built with docker build and is ready to deploy to the host.

From the Docker client, when we run docker run [image name], the client RPCs to the Docker daemon via a Linux socket to begin provisioning the Docker image layers (basically readable and writable manifests and tarballs) to provision the docker container runtime.

Why Is Docker Security Important?
Docker’s inherent system design is not secure by default.
As the daemon needs to create namespaces for isolation (more on this in the next lesson), docker buildis run with root privileges by design. This design is a significant security risk as the user can run any command and the daemon will process it.
Docker unprotected ports can and have been attacked in malware campaigns
As you can see, the client, host, and registry are deeply involved in Docker operations. Due to design decisions, each of these components has attack surfaces that needs to be considered from a security engineering perspective.

New Terms
Tarball: A tarball or tarfile is the name of a group or archive of files that are bundled together using the tar command. They usually have the .tar file extension. If the tar file is compressed using the gzip command, the tarball will end with .tar. Sometimes ZIP files are also called tarballs.
Docker daemon is the engine that processes commands from the client to manage Docker containers.
Docker client is how you interact with the Docker daemon through a command-line interface.
Docker host is the machine on which docker is installed that hosts the containers.
Docker Hub registry is where docker images are stored.
Additional Resources
For further reading on Docker, please consider the following resources:

Docker Architecture docs
Dockerfile best practices docs
Docker command line build docs
Unprotected open Docker API ports
Books:

Liz Rice | Container Security: Fundamental Technology Concepts that Protect Containerized Applications



2.9 Docker Threat Modeling with STRIDE
---------------------------------------
What Could Go Wrong?
Docker Client
Client compromise: the Docker desktop running on the administrator's machine
Client authorization abuse: abuse of the client's authorization to make privileged changes
Dockerfile misconfiguration: how the Dockerfile is built
Docker Host
Isolation tampering: we are very concerned with namespace isolation to prevent container escape attacks
Use of --privilege flag
Insecure defaults
Misconfiguration
Docker Registry - the largest attack surface
Image security
Open Source Software (OSS) security
Docker registry security

Evaluating Docker Client Using STRIDE
Spoofing - Client traffic from the Docker client to the Docker daemon or registry could be spoofed, or intercepted by a malicious party and replayed. Transport Layer Security (TLS) can be implemented to secure communication affecting the client.
Tampering - An attacker gets control of the Docker client. This could lead to tampering of the Dockerfile that’s used to build the image affecting Dockerfile.
Repudiation - Once the client is compromised, the attacker may use it to make changes that are not legitimate, which could impact the Dockerfile.
Information Disclosure - The client may expose sensitive information such as secrets that are hardcoded in configuration files that could impact the security of the Dockerfile.
Denial of Service - Excessive traffic from the client could overwhelm the daemon (often on the same machine) and could cause it to crash, leading to a client compromise.
Elevation of Privilege - when a Dockerfile does not specify a user, it defaults to executing the container using the root user, affecting client authorization and the Dockerfile.

Evaluating Docker Host Using STRIDE
Spoofing - This can occur when a sidecar container has intentional access to the primary container's namespace and may spoof the namespace used by the primary container, resulting in isolation tampering. You should be careful with using sidecar containers.
Tampering - Daemon configuration may be tampered with by a compromised client, leading to misconfiguration.
Repudiation - A user may make changes to the daemon that are not legitimate, leading to misconfiguration.
Information Disclosure - The Docker host file system may be misconfigured, exposing sensitive information and leading to insecure defaults.
Denial of Service - Daemon memory for the running container may be over-allocated, leading to a misconfiguration.
Elevation of Privilege - Daemon privilege may be escalated if a user name is not defined and the container runs as root, which gives access to any other container on the same host, leading to isolation tampering.

Evaluating Docker Registry Using STRIDE
Spoofing - Authenticity of images is a big concern as we put a lot of trust in them. An image may be spoofed with malicious images or libraries as part of the container layers, which affects image security.
Tampering - Container image may be tampered with, leading to supply chain injections. This is the biggest risk regarding the supply chain. An attacker may implant a malicious image into the image registry and entice organizations to use it. Alternatively, an attacker may introduce open source libraries in popular hosted repositories and encourage organizations to use them. This can affect both image security and Open Source Software security.
Repudiation - Malicious images may be committed without authorization by an attacker. This affects image security.
Information Disclosure - Sensitive data such as secrets may be left in the container image and exposed at runtime affecting image security and potentially much more, depending on the scope of the credentials. This would affect image security.
Denial of Service - Docker distribution may not properly restrict the amount of content accepted by a user. This allows remote attackers to cause a denial of service. This could affect registry security.
Elevation of Privilege - Container image permissions may be elevated using the --privilege flag. Image libraries may contain security flaws. This can affect image security.

New Terms
Sidecar container: A container that runs alongside the primary container in a pod. Sidecars are often used for logging or security use cases.
Namespace: A Linux native control that isolates or partitions resources such that one set of processes cannot see the resources of another set of processes.
Isolation: The state of being separated, both in a physical and virtual sense. On the Linux operating system, isolation allows each process to have its own isolated world to run processes.

Additional Resources
For further reading on Docker, please consider the following resources:

Getting started with STRIDE
Threat modelng Manifesto



2.10 Quiz: Threat Model Docker with STRIDE
---------------------------------------
q1
docker client
docker client
docker host
docker host
docker host
docker registry
docker registry
docker registry

q2
insecure defaults
may be misconfigured

2.11 Exercise: Threat Model Docker with STRIDE
---------------------------------------
q1
docker client
docker host
docker registry

q2

Docker Client
Client compromise: the Docker desktop running on the administrator's machine
Client authorization abuse: abuse of the client's authorization to make privileged changes
Dockerfile misconfiguration: how the Dockerfile is built

Docker Host
Isolation tampering: we are very concerned with namespace isolation to prevent container escape attacks
Use of --privilege flag
Insecure defaults
Misconfiguration

Docker Registry - the largest attack surface
Image security
Open Source Software (OSS) security
Docker registry security



2.12 Solution: Threat Model Docker with STRIDE
---------------------------------------
Solution: Threat Model Docker with STRIDE
Docker Threat Model Summary
Given the four areas most relevant to Docker security, let's evaluate what could go wrong with this docker model based on the provided information. As we learned in the lesson, containers have their own unique attack surface.

1. The three primary Docker components that are most relevant to Docker security
Docker Client: We are concerned with the compromise of the docker desktop running on the administrator's machine, abuse of the client's authorization to make privileged changes, and how the Dockerfile is built.
Docker Host: Docker host also has a large attack surface. We are very concerned with namespace isolation to prevent container escape attacks, use of the --privileged flag, insecure defaults, and misconfiguration.
Docker Registry: Docker Registry is the largest attack surface which has the most external implications. We are concerned with image security, open-source component security, and Docker registry security.
2. Given Docker's system components and the STRIDE framework, identify potential threats that may arise. I provide an example for three aspects of STRIDE.
Spoofing of network traffic: Docker supports the addition and removal of capabilities. You should remove all capabilities not required for the correct function of the container. Specifically, in the default capability set provided by Docker, the new_raw capability should be removed if not explicitly required, as it can give an attacker with access to a container the ability to create spoofed network traffic.
Tampering: Docker provides a TLS CA certificate file to allow secure communication between the Docker server and the client. This file should be protected from any tampering. It is used to authenticate the Docker server based on a given CA certificate. It must therefore be individually owned and group-owned by root to ensure that it cannot be modified by less privileged users to avoid tampering.
Denial of Service: By default, a container can use all of the memory on the host. You can use memory limit mechanisms to prevent a denial of service from occurring, where one container consumes all of the host’s resources and other containers on the same host are therefore not able to function. Denial of Service protection could result in exhausting resources needed to provide the service and lead to an outage.
With this more elaborate exercise, we identified 3 concrete threats on Docker using the STRIDE model.

Review
Through this more complex exercise, we evaluated the threat model for Docker at a high level. Although all responses will be marked as "correct", I encourage you to compare your response with the solution and think about the differences.

When evaluating this environment against STRIDE, it's important to think about the implications of the foundational design. For example, if you are not familiar enough with the core properties of Docker in order to evaluate threats, I would encourage you to rewatch the earlier courses and/or read official docker documentation. If you found this exercise more difficult than expected, I would encourage you to read the Docker CIS Benchmark in the starter exercise repo, as it does a wonderful job outlining the system security weaknesses very thoroughly to get you started.

While there is no "single right answer", the goal is to understand how to threat model in a systemic and methodical way. Before you can objectively evaluate the security properties of a system, you need to understand the system architecture, boundaries, and core entities.

As we progress through the course and go deeper into Docker, our threat models will become even more sophisticated. However, the basic foundation questions will be the same:

What could go wrong?
What are we going to do about it?
How do we know our mitigations are good enough?
Next, we will work to apply the STRIDE methodology to concretely evaluate Kubernetes' primary components.



2.13 Kubernetes Threat Fundamentals
---------------------------------------
Kubernetes Recap
Kubernetes is a distributed orchestrator for Docker containers. Kubernetes is a complicated system. At the highest level, Kubernetes consists of a control plane and a data plane.

Control Plane - the Collection of Master Nodes
The Control plane contains the following 5 service entities:

kube-apiserver is the primary control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane.
etcd is a consistent and highly-available key-value store used as Kubernetes' backing store for all cluster data.
kube-scheduler is a control plane component that watches for newly created Pods with no assigned node and selects a node for them to run on.
kube-controller-manager runs the controller processes. Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.
cloud-controller-manager is an optional component that exposes the Kube API to cloud providers like AWS and GCP to orchestrate Kubernetes. As it has an attack surface, we are including it in the lesson.

Data Plane - the Collection of Worker Nodes
The Data plane contains the following 2 service entities:

kubelet is an agent that runs on each node in the cluster. It makes sure that containers are running in a Pod.
kube-proxy is a network proxy that runs on each node in your cluster, maintaining network rules on nodes. These network rules allow network communication to your Pods from network sessions inside or outside of your cluster.
Source:

Kubernetes documentation licensed under CC BY 4.0
OWASP Kubernetes Security Cheat Sheet, licensed under Creative Commons Attribution 3.0 Unported License

Kubernetes Threat Basics - Four Cs
Let's think about the Kubernetes orchestrator for a single node as a layered threat model with 4 Cs: Code, Container, Cluster, Cloud security layers, from inside out, as illustrated by the diagram below.

Each layer has unique considerations that should be evaluated.

Code
The application code you write and deploy within your container.
To harden this, we should avoid system application security flaws and vulnerable libraries in the application code.
Docker Container
To harden this, we should protect the Docker client, host, and registry.
We should also look into container escape vulnerabilities. Left unpatched, it allows hackers to break out of sandboxes and gain root access on the host servers, compromising the entire infrastructure.
Kubernetes Cluster
To harden this, we should secure the control and data plane environment using configurable policies and secure the applications that run on the cluster through isolation and hardening.
Cloud
Most Kubernetes clusters are hosted on Cloud providers such as AWS or GCP. Even if you host your own cluster, you will ultimately need physical servers to deploy the workload. As the cloud provider has privileged access to the kube-apiserver, it’s vital to limit the attack surface.
For the purposes of this course and specific cloud provide implementations, we will not cover specific cloud provider security considerations nor in-depth cloud-controller-manager hardening.
Additional Resources
For further reading on Kubernetes, please consider the following resources:

Overview of Kubernetes Cloud Native Security
Books:

Kelsey Hightower | Kubernetes: Up and Running: Dive into the Future of Infrastructure 2nd Edition
Kaizhe Huang | Learn Kubernetes Security: Securely orchestrate, scale, and manage your microservices in Kubernetes deployments




