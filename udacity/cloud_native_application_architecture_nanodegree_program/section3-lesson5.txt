date start : 02 september 2021


5.1 Lesson Overview
---------------------------------------
So far, we've learned about how to design our microservice applications and implement various message-passing techniques that work best for our architecture. Now we want to take a look at message passing in production systems.

Tools and strategies can improve how message passing is used in production systems.

In this lesson, we'll learn how message passing is implemented in production. We'll go over:

Combining Techniques
Open API Documentation
Iterating on APIs
Future-Proofing



5.2 What is Different About Production?
---------------------------------------
As we use microservices, all of our business functionality is communicating with one another through networks. It's important to optimize for business value when we are implementing our services.

Production Systems
Production systems are exposed to more sources of failure than those running in development environments.

Testing our services locally is only one part of the puzzle: applications don't exist in a vacuum.
Production systems undergo the stress from active users and can break from unanticipated edge cases.
Application Lifecycle
Our applications are rarely a one-and-done ordeal and involves maintenance and additional development as we iterate on features.
The original developer or team of developers that built the system may no longer be around to support the application.

q1
Increased user activity
Large volumes of messages
Security exploitations



5.3 How Experts Approach Message Passing in Production
---------------------------------------
Not Simply Coding
Delivering business value is not always about writing code.
System design plays an integral part in ensuring that our business needs are met.
We should also be conscious of the maintainability of our applications.
We should ensure that the team has the right resources to implement new services or features when needed.
Interfaces in Production
With software, we can deliver products and then iterate to add more features and solve bugs.
With hardware, the product must be thoroughly tested and validated before it can be sold to the customers because making changes is difficult.
It is common to be undisciplined about interfaces because it is so convenient and simple to modify code.

I've encountered a handful of situations where the interface for an API was changed without consideration for its users and ended up causing downtime for its dependents. Once we deliver an API and define its interface, we need to be conscious of breaking changes.

It's important to understand how we can make minor and major changes to an API after it's been delivered and used by users.

q1
Easier onboarding for new teammates
Simpler refactoring



5.4 Combining Message Passing Techniques
---------------------------------------
Combining Message Passing Techniques
Message passing techniques do not need to be disjointed from one another. We can use them with one another to make our APIs more performant and robust with tradeoffs regarding latency, cost, and more sources of failure.

Examples
The following are a few simple examples of how we can combine message passing techniques to improve our applications' designs.

Message Queue and REST
A queue can be placed in front of a RESTful API.

Allows us to configure asynchronous requests in the REST API
Makes the REST API requests more durable and less prone to failure from load
Creating a queue in addition to an existing REST API will need additional resources such as servers and development efforts

Exposing Message Queues
Message queues can be exposed publicly with a RESTful API.

Queues should be exposed in a controlled manner because Kafka doesn't have enforcement of data that enters the queue
Creating a REST API in addition to an existing queue will need additional resources such as servers and development efforts
Adding a REST API introduces more sources of failure in our system as it can break from an abnormally large number of requests

gRPC and REST
We can expose a service with multiple interfaces.

Expose both gRPC and REST as an interface to satisfy different use cases for different users
Additional resources needed to create two interfaces
Additional resources needed to maintain two interfaces: updating two schemas simultaneously can be cumbersome to deploy



5.5 Quiz: Combining Message Passing Techniques
---------------------------------------
add structure to the messages ingested into kafka


5.6 Exercise: Combining Message Passing Techniques
---------------------------------------
Combining Message Passing Techniques
Our computer orders API receives a lot of traffic, and teams outside of IT leverage this data for analytics. Management has decided that the data should be written into Kafka for durability and better response times.

You have been provided existing code and tasked with updating the REST API input data into a Kafka queue. You will only need to write data into the queue and won't need to concern yourself with reading the messages.

Task
Our REST API will now return a 202 Accepted HTTP response with no response body. It will take the input payload and write the dictionary into Kafka. We don't need to concern ourselves with reading the data off of Kafka to process it.



5.7 Solution: Combining Message Passing Techniques
---------------------------------------

Summary
You have been tasked with writing data into a Kafka queue

Write the Computer orders JSON data into Kafka
You don't have to concern yourself with how the Kafka data is consumed
The API response should now be 202 Accepted with no response body

Tasks
Set up a Kafka broker with a topic for computers
Set up a Kafka producer in the Flask application
Write the computer orders creation data from the REST API into the Kafka queue

Starter Code
app.py imports KafkaProducer
g is a Flask object used to store the Kafka connection so we can use it in other parts of the application
Response is a Flask object used to format API responses with more flexibility. We can declare Response(status=202) whereas jsonify is more rigid and configured to return a 200.
app.before_request runs a method to set up a Kafka connection before an API request
create_order() method has sample code on how to write a Kafka producer

My Process
Run the Kafka broker
Update services.py to write create_order data into Kafka
Update app.py to return an empty 202 response.


q1
it is very structure to fit all the pieces in a systematically steps. when we have more requests coming in, we can add more front end (rest endpoint) to increase the capacity to satisfy the incoming traffics.


Using a Kafka queue with a Flask REST API introduces more complexity to an application. We have additional overhead, such as maintaining a connection to the Kafka broker.



5.8 Using OpenAPI
---------------------------------------
OpenAPI is a specification that provides us with a framework for documenting our RESTful APIs.

The Problem
REST Relies on Documentation
RESTful APIs are highly reliant on their documentation.
REST has little built-in enforcement for message structure and can be changed very easily.

Different developers also use different sets of best practices and may implement their APIs differently from one another. I have worked with non-documented or poorly-documented REST APIs in the past: it's not fun to have to dig through and read source code to figure out how to structure a simple GET request.

Documentation Can Be Formatted Differently
Documentation is very open-ended and can use different types of formatting and notation.

OpenAPI
The OpenAPI specification provides us with a uniform way to detail our API resources and query for them
OpenAPI includes a wide range of optional fields that enrich our documentation
OpenAPI can be loaded into a tool called Swagger, a user-friendly, interactive API documentation accessible through a web page

OpenAPI Overview I
components.schemas help define reusable components so we can standardize an API interface
paths defines the API endpoints
description enriches documentation by allowing us to explain the API details
path.<method_type>.parameters define API arguments
path.<method_type>responses define what the API will return
InventoryItem is defined in components.schemas.InventoryItem for reusability

paths./items/{itemId}.get defines GET items/<item_id>

OpenAPI Overview
Below is a sample of documentation for a REST API used to manage inventory items.

openapi: 3.0.0
info:
  description: Manage the items in a stockroom.
  version: "1.0.0"
  title: Simple Inventory API
paths:
  /items/{itemId}:
    get:
      summary: Retrieve an item from the inventory
      operationId: getInventory
      description: By passing in an item_id you can retrieve the items information
      parameters:
        - in: path
          name: itemId
          schema:
            type: string
          required: true
          description: ID of the item to get
      responses:
        '200':
          description: Successfully retrieved an item
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InventoryItem'
        '404':
          description: Requested item ID was not found
  /items:
    post:
      summary: Creates an item in the inventory
      operationId: addItem
      description: Adds an item to the Inventory
      responses:
        '201':
          description: Item created
        '400':
          description: Invalid input, object invalid
        '409':
          description: An existing item already exists
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InventoryItem'
        description: Inventory item to add
components:
  schemas:
    InventoryItem:
      type: object
      required:
        - id
        - name
        - brand_name
        - weight
      properties:
        id:
          type: string
          example: 1
        name:
          type: string
          example: Egg Pan
        brandName:
          type: string
          example: "Acme"
        weight:
         type: number
         example: 2.1

Using OpenAPI Part II

OpenAPI Overview II
responses can define different responses depending on the response type
Passing in a reference to a component with $ref helps standardize the API interface
Defining $ref: '#/components/schemas/InventoryItem' is used to standardize the API while reducing code repeat
Navigation Bar
The navigation bar in the left provides an interface to view the documentation in an organized way
Live Preview
SwaggerHub generates the documentation so that we can preview how the OpenAPI spec will be generated
Swagger documentation provides a standardized interface for API documentation
Options For Maintaining API Documentation With Swagger

Options for Maintaining Documentation With Swagger
Manually update OpenAPI specifications file
Use a library to maintain OpenAPI specificatoins with inline comments
Use a library to auto-generate OpenAPI Specifications
Creating Swagger Documentation
Swagger is an interactive tool that accepts OpenAPI documentation as input and provides a user interface for API documentation.
Swagger libraries are available for most programming languages and provide various ways to populate our API documentation.
SwaggerHub is a hosted version of Swagger that provides live previews and an interactive editor to check your OpenAPI syntax.
Maintaining Documentation
Writing and maintaining documentation is often tedious. When we make a few changes to our code, we need to revisit our API documentation and reflect the latest changes.
API documentation often drifts and becomes cumbersome to maintain.
Rather than writing separate documentation for the work that we do, we can use integration tools to make our upkeep of documentation more manageable.
Options for OpenAPI
Manually update and maintain an OpenAPI specification file
This is the traditional way in how we have separate sets of documentation for our APIs.

Example

paths:
  /items/{itemId}:
     get:
      description: Retrieve the item with itemId
      parameters:
        - in: path
          name: itemId
          schema:
            type: string
          required: true
          description: ID of the item to get

Write our API specification as comments, and our libraries translate this into OpenAPI specifications
This makes it easier to upkeep our documentation by keeping the documentation in the same area as our application code. This way, our code and documentation live in the same file, so there is more accountability to keep them consistent.

Example


"""
@oas [get] /items/{itemId}
description: "By passing in an itemId you can retrieve the items information"
parameters:
- (path) category=all* {String} Item itemId
"""
def retrieve_items(item_id):
    # Route logic here
    pass

Use tightly-integrated libraries that will automatically detect how our code is structured and generate OpenAPI specifications for us
Some libraries will allow us to auto-generate documentation. This is the easiest to maintain and provides us little overhead on managing our documentation at the expense of flexibility. When it works, this is a powerful way to optimize productivity.

Example


@api.route("items/<item_id>")
@api.param("item_id", "Unique Item ID", _in="query")
class ItemResource(Resource):
    @responds(schema=ItemSchema)
    def get(self, item_id) -> Item:
        # API Logic
        pass

When OpenAPI Doesn't Work...
I worked on a project where I tried to use auto-generating documentation and found that since my API design did not conform to OpenAPI specification best practices, my documentation couldn't be auto-generated.

New Terms
Term	Definition
OpenAPI	Provides a uniform way to detail and query API resources. It includes a wide range of optional fields that enrich our documentation
Swagger	A tool used to render OpenAPI specifications into an interactive web page
SwaggerHub	A tool that provides utilities to write OpenAPI specifications more easily as well as live previews of the corresponding Swagger documentation

Further Reading
The following are additional resources to learn about Swagger and its usefulness in applications:

Interactive Swagger Editor
Why API Documentation Matters



5.9 Quiz: Using OpenAPI
---------------------------------------
Updating code will update documentation automatically
Reduce time to release a production application



5.10 Exercise: Applying Open API
---------------------------------------
Applying OpenAPI
Create an OpenAPI specification for our computer orders REST API. We want to make sure that users of the API know how to set up their integrations to retrieve all orders and create a new order.




5.11 Solution: Applying OpenAPI
---------------------------------------
OpenAPI Specification
The following is an OpenAPI specification for a computer orders API. It details the ComputerOrder schema as well as the path /orders/computers to create and retrieve computer orders.

openapi: 3.0.0
info:
  description: API for ordering computers from IT
  version: "1.0.0"
  title: Computer Orders API
paths:
  /orders/computers:
    get:
      summary: Retrieves all computer orders
      operationId: getComputerOrders
      description: Retrieves all the computer orders that have been created.
      responses:
        '200':
          description: All computer orders
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ComputerOrder'
        '400':
          description: Bad input parameter
    post:
      summary: Adds a computer order
      operationId: addInventory
      description: Creates a computer order by setting an order in the QUEUED state.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ComputerOrder'
        description: Computer order that was created
      responses:
        '201':
          description: Computer order created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ComputerOrder'
        '400':
          description: 'Invalid input, object invalid'
components:
  schemas:
    ComputerOrder:
      type: object
      required:
        - id
        - status
        - created_by
        - created_at
        - equipment
      properties:
        id:
          type: string
          example: '1'
        status:
          $ref: '#/components/schemas/Status'
        created_by:
          type: string
          example: 'USER1'
        created_at:
          type: string
          format: date-time
          example: '2016-08-29T09:12:33.001Z'
        equipment:
          type: array
          items:
            $ref: '#/components/schemas/Equipment'
    Equipment:
      type: string
      enum:
        - KEYBOARD
        - MOUSE
        - WEBCAM
        - MONITOR
    Status:
      type: string
      enum:
        - QUEUED
        - PROCESSING
        - COMPLETED
        - FAILED



q1
well, u can test your api by using openapi in the interface. if the request and response data is not structure, then in this case, does not make sense to use OpenAPI.


OpenAPI is a useful tool but, it isn't always necessary to apply to our applications. It can add more complexity to documentation management when it's not warranted.




