date start : 02 september 2021


5.1 Lesson Overview
---------------------------------------
So far, we've learned about how to design our microservice applications and implement various message-passing techniques that work best for our architecture. Now we want to take a look at message passing in production systems.

Tools and strategies can improve how message passing is used in production systems.

In this lesson, we'll learn how message passing is implemented in production. We'll go over:

Combining Techniques
Open API Documentation
Iterating on APIs
Future-Proofing



5.2 What is Different About Production?
---------------------------------------
As we use microservices, all of our business functionality is communicating with one another through networks. It's important to optimize for business value when we are implementing our services.

Production Systems
Production systems are exposed to more sources of failure than those running in development environments.

Testing our services locally is only one part of the puzzle: applications don't exist in a vacuum.
Production systems undergo the stress from active users and can break from unanticipated edge cases.
Application Lifecycle
Our applications are rarely a one-and-done ordeal and involves maintenance and additional development as we iterate on features.
The original developer or team of developers that built the system may no longer be around to support the application.

q1
Increased user activity
Large volumes of messages
Security exploitations



5.3 How Experts Approach Message Passing in Production
---------------------------------------
Not Simply Coding
Delivering business value is not always about writing code.
System design plays an integral part in ensuring that our business needs are met.
We should also be conscious of the maintainability of our applications.
We should ensure that the team has the right resources to implement new services or features when needed.
Interfaces in Production
With software, we can deliver products and then iterate to add more features and solve bugs.
With hardware, the product must be thoroughly tested and validated before it can be sold to the customers because making changes is difficult.
It is common to be undisciplined about interfaces because it is so convenient and simple to modify code.

I've encountered a handful of situations where the interface for an API was changed without consideration for its users and ended up causing downtime for its dependents. Once we deliver an API and define its interface, we need to be conscious of breaking changes.

It's important to understand how we can make minor and major changes to an API after it's been delivered and used by users.

q1
Easier onboarding for new teammates
Simpler refactoring



5.4 Combining Message Passing Techniques
---------------------------------------
Combining Message Passing Techniques
Message passing techniques do not need to be disjointed from one another. We can use them with one another to make our APIs more performant and robust with tradeoffs regarding latency, cost, and more sources of failure.

Examples
The following are a few simple examples of how we can combine message passing techniques to improve our applications' designs.

Message Queue and REST
A queue can be placed in front of a RESTful API.

Allows us to configure asynchronous requests in the REST API
Makes the REST API requests more durable and less prone to failure from load
Creating a queue in addition to an existing REST API will need additional resources such as servers and development efforts

Exposing Message Queues
Message queues can be exposed publicly with a RESTful API.

Queues should be exposed in a controlled manner because Kafka doesn't have enforcement of data that enters the queue
Creating a REST API in addition to an existing queue will need additional resources such as servers and development efforts
Adding a REST API introduces more sources of failure in our system as it can break from an abnormally large number of requests

gRPC and REST
We can expose a service with multiple interfaces.

Expose both gRPC and REST as an interface to satisfy different use cases for different users
Additional resources needed to create two interfaces
Additional resources needed to maintain two interfaces: updating two schemas simultaneously can be cumbersome to deploy



5.5 Quiz: Combining Message Passing Techniques
---------------------------------------
add structure to the messages ingested into kafka


5.6 Exercise: Combining Message Passing Techniques
---------------------------------------
Combining Message Passing Techniques
Our computer orders API receives a lot of traffic, and teams outside of IT leverage this data for analytics. Management has decided that the data should be written into Kafka for durability and better response times.

You have been provided existing code and tasked with updating the REST API input data into a Kafka queue. You will only need to write data into the queue and won't need to concern yourself with reading the messages.

Task
Our REST API will now return a 202 Accepted HTTP response with no response body. It will take the input payload and write the dictionary into Kafka. We don't need to concern ourselves with reading the data off of Kafka to process it.



5.7 Solution: Combining Message Passing Techniques
---------------------------------------

Summary
You have been tasked with writing data into a Kafka queue

Write the Computer orders JSON data into Kafka
You don't have to concern yourself with how the Kafka data is consumed
The API response should now be 202 Accepted with no response body

Tasks
Set up a Kafka broker with a topic for computers
Set up a Kafka producer in the Flask application
Write the computer orders creation data from the REST API into the Kafka queue

Starter Code
app.py imports KafkaProducer
g is a Flask object used to store the Kafka connection so we can use it in other parts of the application
Response is a Flask object used to format API responses with more flexibility. We can declare Response(status=202) whereas jsonify is more rigid and configured to return a 200.
app.before_request runs a method to set up a Kafka connection before an API request
create_order() method has sample code on how to write a Kafka producer

My Process
Run the Kafka broker
Update services.py to write create_order data into Kafka
Update app.py to return an empty 202 response.


q1
it is very structure to fit all the pieces in a systematically steps. when we have more requests coming in, we can add more front end (rest endpoint) to increase the capacity to satisfy the incoming traffics.


Using a Kafka queue with a Flask REST API introduces more complexity to an application. We have additional overhead, such as maintaining a connection to the Kafka broker.




