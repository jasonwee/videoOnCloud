date start : 02 september 2021


5.1 Lesson Overview
---------------------------------------
So far, we've learned about how to design our microservice applications and implement various message-passing techniques that work best for our architecture. Now we want to take a look at message passing in production systems.

Tools and strategies can improve how message passing is used in production systems.

In this lesson, we'll learn how message passing is implemented in production. We'll go over:

Combining Techniques
Open API Documentation
Iterating on APIs
Future-Proofing



5.2 What is Different About Production?
---------------------------------------
As we use microservices, all of our business functionality is communicating with one another through networks. It's important to optimize for business value when we are implementing our services.

Production Systems
Production systems are exposed to more sources of failure than those running in development environments.

Testing our services locally is only one part of the puzzle: applications don't exist in a vacuum.
Production systems undergo the stress from active users and can break from unanticipated edge cases.
Application Lifecycle
Our applications are rarely a one-and-done ordeal and involves maintenance and additional development as we iterate on features.
The original developer or team of developers that built the system may no longer be around to support the application.

q1
Increased user activity
Large volumes of messages
Security exploitations



5.3 How Experts Approach Message Passing in Production
---------------------------------------
Not Simply Coding
Delivering business value is not always about writing code.
System design plays an integral part in ensuring that our business needs are met.
We should also be conscious of the maintainability of our applications.
We should ensure that the team has the right resources to implement new services or features when needed.
Interfaces in Production
With software, we can deliver products and then iterate to add more features and solve bugs.
With hardware, the product must be thoroughly tested and validated before it can be sold to the customers because making changes is difficult.
It is common to be undisciplined about interfaces because it is so convenient and simple to modify code.

I've encountered a handful of situations where the interface for an API was changed without consideration for its users and ended up causing downtime for its dependents. Once we deliver an API and define its interface, we need to be conscious of breaking changes.

It's important to understand how we can make minor and major changes to an API after it's been delivered and used by users.

q1
Easier onboarding for new teammates
Simpler refactoring



5.4 Combining Message Passing Techniques
---------------------------------------
Combining Message Passing Techniques
Message passing techniques do not need to be disjointed from one another. We can use them with one another to make our APIs more performant and robust with tradeoffs regarding latency, cost, and more sources of failure.

Examples
The following are a few simple examples of how we can combine message passing techniques to improve our applications' designs.

Message Queue and REST
A queue can be placed in front of a RESTful API.

Allows us to configure asynchronous requests in the REST API
Makes the REST API requests more durable and less prone to failure from load
Creating a queue in addition to an existing REST API will need additional resources such as servers and development efforts

Exposing Message Queues
Message queues can be exposed publicly with a RESTful API.

Queues should be exposed in a controlled manner because Kafka doesn't have enforcement of data that enters the queue
Creating a REST API in addition to an existing queue will need additional resources such as servers and development efforts
Adding a REST API introduces more sources of failure in our system as it can break from an abnormally large number of requests

gRPC and REST
We can expose a service with multiple interfaces.

Expose both gRPC and REST as an interface to satisfy different use cases for different users
Additional resources needed to create two interfaces
Additional resources needed to maintain two interfaces: updating two schemas simultaneously can be cumbersome to deploy



5.5 Quiz: Combining Message Passing Techniques
---------------------------------------
add structure to the messages ingested into kafka



