date start : 25 august 2021


2.1 Lesson Overview
---------------------------------------
In this lesson, we will look at how we can strategically approach refactoring a monolith application into microservices. We will look at how we can systematically prioritize what parts of a monolith to refactor and then how to practically refactor a production system.

By the end of this lesson you will be able to:

Create a dependency map to prioritize refactoring a service based on business logic
Develop an appropriate migration strategy for a specific use case
Apply the strangler pattern to migrate a service from a monolith into its own microservice


2.2 Why Do Microservices Matter?
---------------------------------------
Monoliths versus Microservices
Monoliths and microservices are two architectural design patterns in how our applications are organized and deployed.

What is a Monolith Architecture?
Self-contained application that is deployed as one unit

Monoliths are applications that are deployed as one unit: rolling out changes to code means replacing an entire system with one release.
What is a Microservice Architecture?
Independently-deployed applications that communicate through networks

Microservices are independent services that communicate with one another and are deployed separately.
Rolling out changes to code in one service should have minimal impact on other services as they are relatively isolated.
Monoliths Aren't Bad!
Despite the enthusiasm today with building applications as microservices, monoliths aren't necessarily bad. The decision to build an application as a monolith or microservice is a design decision weighing tradeoffs:

Monoliths are easier to develop and have less overhead for infrastructure.
Microservices are more scalable and enable parallel development as multiple developers can easily work simultaneously on different parts of the application.
Refactoring each microservice to make small changes can become frustrating and overwhelming



q1
Monoliths can be deployed as a single unit, whereas microservices have multiple deployments
Monoliths are easier to set up than microservices


2.3 How Experts Approach Refactoring
---------------------------------------
It's Safer to Start with a Monolith
Software that we build is often changing as business requirements evolve
When in doubt, it's safer to start as a monolith
Refactoring a monolith to microservice is easier than microservice to monolith

Microservice Complexity
Microservices are inherently more complex than monoliths.
Microservices have more moving pieces: services are individually deployed and communicate through a network.
Microservices are a distributed system. Distributed systems come with new properties that inherently make it more complex than a single-node system like a monolith. All distributed systems are inevitably at risk for network failures and need additional overhead to manage the inherent risk.

Working with Microservices
Without the support of a good developer toolchain, Microservices are more cumbersome to work with. A good overview of the different types of developer tools supporting can be found in this article.
More overhead to manage when we need to make major changes that affect the whole system
It's often easier to migrate an application from a monolith to microservice architecture than a microservice to monolith architecture.

Case Study
I once worked at a fast-paced startup where we would pivot or change our applications to meet new business needs. When we were informed of these changes, we were able to work quickly to make changes and push out new features and deprecate obsolete code. Thankfully, our applications at the time were built as monoliths, and it was easy to address these changes since they were typically localized in only a few areas. Imagine having spent so much effort to build your application as elegant microservices -- only to find out that half of your business logic is now obsolete. It would be frustrating and not productive to have to rework and redeploy code across multiple deployments.

q1
Scale vertically by increasing the hardware.

q2
Keep the application as is.

q3
An enterprise application that needs to have downtime scheduled every night for any code changes
A company that wants two established teams that use different programming languages and frameworks to collaborate


New Terms
Term	Definition
Distributed System	Multiple nodes that communicate with one another as part of a system



2.4 Preparing to Refactor a Monolith
---------------------------------------
Approaching Refactoring a Monolith
A skilled developer would not blindly design and build everything as microservices!
Look at the system from a bird's eye view to understand the relationships between services with a dependency graph.

Dependency Graphs
A dependency graph is a way to visualize how pieces of a system relate to one another.
Dependency graphs capture the modules and their dependencies as a directed graph.
Helps us understand the downstream impact of the changes made in one module.
Establishes an understanding of the system to see business risks associated with modifying one part of the system over another.

How to Get Started Creating a Dependency Graph
Review source code
Review existing documentation
Understand external use cases

Details in Graphs
Dependency graphs involve nodes and arrows that capture the relationship between the modules that are linked.

Nodes
Nodes represent a resource: these can be distinct servers, systems, or subcomponents of your application
The level of detail to provide in a node depends on what type of information you are trying to capture with the dependency graph

Arrows
Arrows capture the relationship between resources that are linked
The direction of arrows can differ depending on what type of information you are capturing
A diagram should not have different conventions for how arrows are directed as it makes the diagram confusing to understand
Because I often work with systems that transport data, I personally like my arrows to help represent how data is flows through my system.

REST API Endpoint

from services.orders import get_order_data
from services.customers import get_customer_data

@app.route('/order/<order_id>')
def get_order(order_id=0):
 order_data = get_order_data(order_id)
 customer_data = get_customer_data(order_data['customer_id'])

 return {
   'order_id': order_id,
   'purchase_price': order_data['purchase_price'],
   'customer_data': customer_data
 }

New Terms
Term	Definition
Dependency Graph	A visual representation of how different components of a system interact with one another

Learn More About Preparing to Refactor a Monolith
Read the following to learn how dependency graphs are used and why distributed systems are more difficult to manage:

Dependency Graphs in Webpack
SJSU Dependency Graphs
CAP Theorem
ï¿¼


2.5 Quizzes: Dependency Graphs
---------------------------------------
q1
C

q2
Understanding how shutting down one service will affect another
Capturing an overview of a complicated system to understand security vulnerabilities
Creating a playbook for redeploying services in the event of a major failure



2.6 Exercise: Build a Dependency Graph
---------------------------------------

user@localhost:~$ sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   633  100   633    0     0   8915      0 --:--:-- --:--:-- --:--:--  8915
100 12.1M  100 12.1M    0     0  6320k      0  0:00:01  0:00:01 --:--:-- 7103k
user@localhost:~$ ls -l /usr/local/bin/docker-compose
-rw-r--r-- 1 root root 13M Aug 21 11:10 /usr/local/bin/docker-compose
user@localhost:~$ sudo chmod +x /usr/local/bin/docker-compose
user@localhost:~$ ls -l /usr/local/bin/docker-compose
-rwxr-xr-x 1 root root 13M Aug 21 11:10 /usr/local/bin/docker-compose
user@localhost:~$ docker
docker                         dockerd                        dockerd-rootless.sh            docker-proxy                   
docker-compose                 dockerd-rootless-setuptool.sh  docker-init                    
user@localhost:~$ docker-compose --version
docker-compose version 1.29.2, build 5becea4c
user@localhost:~$ 




2.7 Solution: Build a Dependency Graph 
---------------------------------------

dependency graph give an quick overview how the code depend on each others...it give an initial idea where are the pieces related. This overview actually help during going through the code..

2.8 Migration Strategy
---------------------------------------

Migration Options
On a high level, we have three options for migrating an existing monolith application to microservices. There's no right or wrong approach -- it depends on which strategy best fits your business requirements.

Rewrite the application
Refactor the existing application
Migrate the existing application in pieces

Rewrite the Application
An effort to refactor can be a good opportunity to rewrite an outdated application.
Be mindful that it's not always a good idea to rewrite everything, and it's easy to lose track of the scope of rewrites.

Refactor the Existing Application
Break apart the application into individual microservices and redeploy the finished refactor at once.
We will need to make sure that our refactored application does not fall behind on features.

Migrate the Existing Application Incrementally
An application can be refactored incrementally while it's live.
We don't need to deploy a copy of the application and work on two simultaneous projects.
Refactor in small increments so that we have time to ensure our application behaves as expected.
Gradual refactoring is known as the Strangler Pattern.

The Strangler Pattern
The Strangler Pattern is a common way to migrate legacy applications. Rather than replacing your code with a new version, you can gradually replace components of your application.

New Terms
Term	Definition
Strangler Pattern	A strategy for gradually refactoring pieces of a deployed application



2.9 Quizzes: Migration Strategy
---------------------------------------
q1
To reduce the risks that might arise from changing too many pieces of an application at the same time

q2
To reduce risk and make debugging more straightforward by localizing all the changes to one part of the application.



2.10 Exercise: Apply The Strangler Pattern
---------------------------------------
Applying The Strangler Pattern
You are tasked with refactoring the UdaCredit Union monolith application. Review the dependency graph below and decide which service to refactor first using the Strangler Pattern. Your goal is to determine which service would have the least amount of risk. Keep in mind there can be more than one right answer -- your solution needs to include your rationale for your decision!

Review the dependency graph and determine which part of the application is the least risky to refactor.
Analyze the dependency graph.
Determine which part of the application makes the most sense to begin refactoring using the Strangler pattern.
Write 2-3 sentences justifying your decision.


q1
I would pick customers route and customers service because these are the least components (2) to begin refactoring. Frontend client require customers route and customers route require customers service. So if these two get refactors, it will work for the Frontend Client.



2.11 Solution: Apply The Strangler Pattern
---------------------------------------
Employees Route
This has 1 dependent and 1 dependency. It could be a candidate for refactoring but there may be better options.

Frontend Client
This has 2 dependencies and 0 dependents. There's no downstream impacts so it could be a great area to start.

Notifications Route
This has 2 dependencies and 0 dependents. There's no downstream impacts so it can be a great area to start.

Customers Route
When we look at the graph as a system, Customers Route along with Customers Service is much more decoupled from the rest of the application. Changes are more isolated and not cross-service. They are less likely to impact other parts of the system.

Tie Breaker
We can consider business context for each of the potential refactor candidates.

At the same time, Customers Service has logic that is much less tied to other parts of the API monolith. It may make sense to work with Customers Route and Customers Service.

q1
sure, because refactoring decision will need to include business criteria too. It could also include like the application context.



2.12 Migrate from Monolith to Microservice
---------------------------------------
Using the Strangler Pattern
The Strangler Pattern provides a systematic approach to approaching our refactor. We want to look at how we can take these concepts and actually begin the work to refactor a monolith to individual microservices.

Refactoring with Kubernetes
With Kubernetes, we can break apart our services into distinct Kubernetes services.
We can begin to represent our application as multiple Docker images that are run as pods in multiple services.
Kubernetes uses message passing to communicate between pods and services.

Premature Abstractions
Developers looking to reduce duplicate code may force non-ideal abstractions in their code. These types of abstractions are deceiving because they remove duplicate code and make the codebase seem more streamlined. However, the bad abstraction makes the code too rigid for changes.

Don't force an abstraction to reduce code. You may find yourself with messy code that you need to accommodate; your abstraction should accommodate your code!

Example
Starting Point
Given that we have a store selling basketball and baseball equipment with the following types of message formats:

Basketball

name: basketball
ball size: large
players: 10
Baseball

name: baseball
ball size: small
players: 9
Forced Abstraction
We may see that there are common fields and decide to refactor our code to enforce that all of our sports follow this schema:

AbstractSport

name:
ball size:
players:
Effect
When another sport is introduced, we may find that the abstraction had been too rigid. If the store begins to sell ice skating equipment, the abstraction starts to break apart:

Ice Skating

name: skating
ball size: ?
players: 1
We can combat this by setting ball size as an optional/nullable field but this is a band-aid fix. As we accumulate more of these nullable fields to accommodate for our abstraction, we accrue more and more technical debt.

It's Fine To Have Duplicate Code
It's a common misconception that code duplication is wrong in software. Production code is a living thing that evolves as business requirements change.
The Do Not Repeat Yourself (DRY) principle is sometimes overly applied to every situation that makes our application too rigid.
Some developers will force themselves to find a way to write abstractions for code that may not be prime candidates for abstractions.
It will be inevitable that you will have duplicate code. At the end of the day, it's fine to have code duplication.

Minimizing Duplicate Code
Common Libraries
Common code can be abstracted into a library that is imported across our application.
If we find that we have a lot of common utility functions, it's possible to publish this common code as its own library that we import to our other services.

Shared Common Code
It's a common approach to have our microservices organized as submodules in one project. * We can possibly organize our project such that it references the same code.
This may look like this:

modules/service_one.py
modules/service_two.py
common/utils.py

Keep Duplicate Code
My recommendation: focus on refactoring your application to microservices.
Once you are done, you will have a better understanding of the shared components in your code.
You can follow up with abstraction techniques to remove duplicate code if it makes sense to do so.

New Terms
Term	Definition
Do Not Repeat Yourself (DRY)	A principle in software that encourages code reuse and applicable abstractions
Learn More About Migrating From Monolith to Microservices
Below are two very insightful articles on a different perspective of opting to overcomplicate abstractions instead of simply having duplicate code:



2.13 Quizzes: Migrate from Monolith to Microservice
---------------------------------------


2.14 Exercise: Migrate from Monolith to Microservice
---------------------------------------



2.15 Solution: Migrate from Monolith to Microservice
---------------------------------------




2.16 Refactoring Live Services
---------------------------------------




2.17 Quizzes: Refactoring Live Services
---------------------------------------



2.18 Exercise: Refactoring Live Services
---------------------------------------


2.19 Solution: Refactoring Live Services
---------------------------------------


2.20 When NOT to Refactor
---------------------------------------



2.21 Quizzes: When NOT to Refactor
---------------------------------------



2.22 Lesson Recap
---------------------------------------


2.23 Glossary
---------------------------------------



