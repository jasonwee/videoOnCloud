date start : 27 august 2021


3.1 Lesson Overview
---------------------------------------

We have decided what our microservices will look like. Now that we have an idea of how to separate services, we will need to begin looking at how we can connect them.



3.2 Why Learn About Message Passing Techniques?
---------------------------------------

One form of message passing less prone to errors than another.
One form of message passing provides lower latency than another.
One form of message passing uses less server resources so less hardware can be used.
One form of message passing is easier to upkeep than another.



3.3 How Experts Approach Message Passing
---------------------------------------
Overview
Different types of message passing are utilized for different scenarios, and they are an integral part of building microservices.

In Practice
Design Considerations
Choosing a message passing technique is a design consideration that weighs technical and business tradeoffs.
There isn't always a solution that optimizes for every use case.
Consider how the system will be affected by your design regarding cost, _maintainability, efficiency, and reliability.

Cost
Be aware of the technical and business implications of our solutions. An experienced engineer can craft solutions that fit within certain constraints.

Maintainability
Our code doesn't exist in a vacuum.
Other developers often contribute to our projects.
We should ensure that our solution is something that someone can reasonably adopt and work with.

Efficiency
Efficiency often refers to the performance of a system: the time it takes to process something.
A system with poor performance can greatly impact the user experience or hinder business functionality.

Reliability
Downtime can be detrimental to our system.
Solutions should be engineered in a way to mitigate downtime: isolate failures and fail gracefully otherwise.

Perfection is Rare
Since software is ever-changing, it is impractical to design a bulletproof solution that will withstand the test of time.
Since we can't predict the future, we should design our system to satisfy our known business requirements. Our code can be engineered in a modular way and enables us to migrate or improve our design.

Example: Cost Tradeoffs
I was once tasked with designing a system to load and retrieve terabytes of data. I came up with the following solutions:

Fastest Solution - load everything into Redis for $300k a month
Fast Solution - load everything into a PostgreSQL cluster for ~$50k a month
Good Solution - use PostgreSQL as a reverse index pointing to data stored in a filesystem ~$9k a month

The cheapest solution was not the most performant but satisfied the business needs with regards to performance and cost. We ended up going with this approach and saved a lot of money!


q1
Adding a cache like Redis to optimize read performance against the database storing the timesheet details
Setting up an auto-scaling application for the timesheet system in case the application can't handle the timesheets being entered
Set up a new technology that a company released in a public beta a month ago that can potentially provide a better user experience for the client's users


q2
cost
maintainability
efficiency
reliability


3.4 REST Application and Best Practices
---------------------------------------
What is REST?
REST stands for "REpresentational State Transfer" and is a set of guidelines on how to create web APIs. As it is a set of guidelines, it is open-ended and can be implemented in many ways.

The industry has settled on a few ideas on best practices for designing APIs with REST.
RESTful APIs and REST APIs are very popular terms today that refer to API's built implementing REST.
RESTful APIs are the most common form of message passing today.

Analogy
It may seem odd that we have a notion of an "architectural style" that simply provides us guidelines on how to implement software. To draw an analogy, let's compare REST to DOT certification for motorcycle helmets:

DOT-Certified Helmets
DOT certification for helmets is a series of guidelines to implement a safe helmet to protect a rider during impacts.
The organization that implemented the DOT certification does not enforce the certification: it's up to individual manufacturers to test their own products.

A manufacturer may decide to use a certain type of foam over a specific type of rubber inside their helmets to absorb shock. One material may absorb more shock over another but cost slightly less. The helmet will still pass the DOT-certification guidelines. We can have many different types of DOT-certified helmets that are optimized for different levels of cost, comfort, safety, and aesthetics.

RESTful API's
Similarly, REST guidelines involve setting up a stateless, client-server relationship leveraging HTTP. How an API makes itself RESTful is open-ended.

Building a RESTful API is not a plug-and-play solution and involves architectural designs of its own.
We have many options on how to build a RESTful design. For example, in a RESTful API endpoint, we can choose to potentially add a cache to improve performance at the expense of additional infrastructure, maintenance, and development.

Properties of RESTful APIs
1. Client-Server
A client makes a request and receives a response from the server.
This relationship provides a good notion of isolation between the client and server: the client doesn't necessarily need to know all the details in how the server is implemented.

2. Statelessness
The server should not be keeping track of the context of client requests.
Each inbound request should have all the information necessary to process the request. This makes the API easier to implement for the server and more predictable for the client.

3. Cacheability
Responses can potentially be cached for improved performance.
This is a server-level detail and abstracted from the client; clients shouldn't care about their responses being cached.

4. Layered System
The client makes requests against an API endpoint and receives a response. The request may have gone through layers of a system.
For example, it may have gone through a proxy, load balancer, different services, etc. before being processed into a response. This is a server-level detail and abstracted from the client; clients shouldn't need to care about the layers involved in their requests.

5. Uniform Interface
The interface should be consistent, and API messages and endpoints should be self-describing.

REST Anatomy
REST is built on top of HTTP requests and responses.

HTTP Request
An HTTP request is sent to the server by the client.

Method - the type of action being taken (POST, GET, PUT, PATCH, DELETE)
Endpoint - URL to send the request
Header - additional metadata
Body - content (typically in JSON format)
HTTP Response
An HTTP response is returned to the client by the server.

Response Code - status of the HTTP request
Header - additional metadata
Body - content (typically in JSON format)
Methods
REST utilizies HTTP methods to define the "verb" of the request. While there are a lot of HTTP methods available, REST typically uses:

POST - create
GET - retrieve
PUT - replace
PATCH - update
DELETE - delete
While not enforced, it's a convention to not include a request body with GET and DELETE methods.

RESTful API Example
Imagine that a supply manager uses an API to manage inventory.

Items Message
The inventory needs to capture information on the unique ID, brand, name, and weight of the inventory item.

We can model this as a JSON object. This captures the data that we need to pass for our system to maintain data on inventory items.

    {
        "id": <item_id: string>,
        "brand_name": <string>,
        "name": <string>,
        "weight": <float>
    }
REST API Interface
The following is an example of a REST API interface that can add items to a warehouse shipment.

Retrieve Item
GET /api/items/<item_id>

Request Headers
Content-Type: application/json

Response Body
{
    "id": <item_id: string>,
    "brand_name": <string>,
    "name": <string>,
    "weight": <float>
}
Create Item
POST /api/items/<item_id>

Request Headers
Content-Type: application/json

Request Body
{
    "id": <item_id: string>,
    "brand_name": <string>,
    "name": <string>,
    "weight": <float>
}
Response Body
{
   "id": <item_id: string>,
    "brand_name": <string>,
    "name": <string>,
    "weight": <float>
}
REST API Specification Format
REST relies heavily on documentation. In general, we will need to include details about our:

URL
Request Type
Headers (if applicable)
Body (if applicable)
Response Code
URL
The URL documents the endpoint as well as path parameters or query parameters.

/api/items/<item_id>?created_by=<user_id>

item_id is a path parameter. It's often used to set the ID of the resource being queried.
user_id is a query parameter. It's often used to control how the data is returned.
Request Type
The Request Type is an HTTP response code. It's often included with the URL.

GET /api/items/<item_id>?created_by=<user_id>

GET indicates that the endpoint supports an HTTP GET request
Headers
Headers are key-value pairs of data. They are often represented by a single string separated by a : character.

Content-Type: application/json

Content-Type is the key and application/json is the value
Body
The body is most often a JSON object. There are many ways to document JSON objects and I prefer the following syntax.

    {
        "id": <item_id: string>,
        "brand_name": <string>,
        "name": <string>,
        "weight": <float>
    }
id captures the key of what the data represents
<item_id: string> tells us that the field represents an item_id and that it is a string type.
<string> tells us that the field is a string type. The field was self-describing enough that we don't have describe what it is representing.
Response Code
The response code informs us of the result of the request. It's often captured as a string that returns us the code and its status. 200 OK

200 is the HTTP response code
OK is the definition of the 200 response. This isn't always needed because HTTP 200 will never mean anything other than an OK so it may be redundant.


New Terms
Term	Definition
REpresentational State Transfer (REST)	An architectural style used to describe how to create web services
Statelessness	Context is not tracked between requests
Cacheability	Ability to store data for efficient retrieval to optimize performance
Client-Server	Relationship where a server provides data to a client that doesn't necessarily need to know the internals of the server's logic
Uniform Interface	Different parts of the interfaces should look familiar and be consistent



3.5 REST APIs In The Real World
---------------------------------------
REST API Best Practices
An elegant RESTful API can become a major selling point for a software company.

Over time, the industry has narrowed in on best practices for building useful RESTful APIs. A great way to learn how to develop a useful API is to review examples from businesses that have been successful partly due to their well-thought-out interfaces.

Example Google Drive API
The Google Drive API is a great example of how we can design a message and expose it through an API. The concept of a file in a filesystem should be a familiar concept and can help provide more clarity on real-world use cases of REST. The Google Drive API is a concrete example of how to capture this data and its interface with REST.

It shows how a File is captured as a JSON object and how to interact with it.

A Files message is used as an object representing a file in Google Drive.
The methods define actions one can make to interact with files.
Learn More About RESTful APIs
API Documentation
Below, I've provided a few companies that are well-known for their APIs. Take a look at some similarities and differences in how they have implemented their APIs to fit their business needs. I highly encourage you to browse -- or even play with -- a few of these!

Stripe - Payment processing product
Twilio - SMS integration product
Plaid - Bank integration product
Trello - Project management product
Digital Ocean - PaaS for hosted infrastructure



3.6 Quizzes: REST Application and Best Practices
---------------------------------------
q1
statelessness
cacheability
layered system
uniform interface

q2
request body
request header
url parameter
url path



3.7 Exercise: Design a RESTful API Interface
---------------------------------------
Design a RESTful API Interface
Before building out an API, it's common to scope out the requirements and model our business requirements into RESTful API interfaces. We will be looking at building a RESTful API endpoint for a hypothetical situation using the concepts we have just learned.

You are part of the IT department for a large national corporation. Every team currently has ad-hoc processes for ordering corporate equipment and the overhead to manage the expenses is becoming unmanageable. The company wants to streamline orders by building a platform to order computer equipment. As part of this initiative, the company wants to build a RESTful API to enable integrations with existing internal portals. Before the development work can begin, you need to design a RESTful API interface for computer orders.

Exercise: Design a RESTful API Interface Task List
We want to implement the following functionality:

Place an order for a computer
Get all computer orders
When a user orders a computer, we want to allow users to specify equipment such as a keyboard or a webcam to include with the order.

An order should contain information on the user who created the order, the status of the order, the time the order was placed, and additional equipment.



3.8 Solution: Design a RESTful API Interface
---------------------------------------
My Solution
Part 1: Create An Order

There are many solutions we can formulate for this exercise. Here are a few examples and rationale for each approach.

Order a Computer
POST <BASE_URL>/api/orders/computers

Here, I've set up a dedicated endpoint for computers. The notion of making an order should be the creation of a computer resource.
For a uniform interface, I would opt to keep all my resources plural. Instead of computer, I use computers. If I were to create another endpoint for chairs, I would name it chairs to maintain a uniform interface.

Request
Request HeaderContent-Type: application/json

Using application/json is a pretty standard header to inform the server that you intend to pass in a JSON response body.


Request Body

{
    "order_id": <order_id: str>,
    "created_by": <user_id: str>,
    "status": <status_enum: str>,
    "created_at": <isoformat_timestamp: str>,
    "equipment": [
        <equipment: str>
    ]
}

This syntax is my personal preference for writing quick notes about how a JSON object should look. You'll notice that many fields are strings in JSON even if they are represented as objects when deserialized. For example, created_at would be a DateTime field in Python, but we have it represented as a string.
Since this is a computers endpoint, we have a field dedicated to specifying the equipment.

Response
Response Code201 Created

A successful response indicates that the resource has been created as requested.

Response Body

{
    "computer_orders": [
        {
            "order_id": <order_id: str>,
            "created_by": <user_id: str>,
            "status": <status_enum: str>,
            "created_at": <isoformat_timestamp: str>,
            "equipment": [
                <equipment: str>
            ]
        }
    ]
}

It is good practice to set your request and response bodies to be the same to increase the uniformity and portability of the API.

Part II: Retrieve An Order

Get computer orders
GET <BASE_URL>/api/orders/computers

Instead of asking the server to create computers resources, we request for them

Request
Request HeaderContent-Type: application/json

Response
Response Code200 OK

A successful response to inform the client that nothing wrong has happened. Often, the first thing code will check for is a successful response.

Response Body

{
    "computer_orders": [
        {
            "order_id": <order_id: str>,
            "created_by": <user_id: str>,
            "status": <status_enum: str>,
            "created_at": <isoformat_timestamp: str>,
            "equipment": [
                <equipment: str>
            ]
        }
    ]
}
Again, this is very similar to the API resources from before. We reuse the same structure and essentially define what it means to be a computers API object.

Alternative Solution
POST <BASE_URL>/api/orders

{
    “order_id”: <order_id: str>,
    "created_by": <user_id: str>,
    "status": <status_enum: str>,
    "created_at": <isoformat_timestamp: str>,
    "details": {
        "type": <type_enum: str>,
        "equipment": [
            <equipment: str>
        ]
    }
}

If our options for orders are more diverse, it may not make sense to have every possible order item as an endpoint. If that's the case, we may opt to maintain a uniform API interface and handle all of our order items with the same endpoint. We know that every order will need a created_by, status, created_at fields. We can stick order-specific details into the details field. It really depends on the business use case.


q1
your solution is much more uniform. i don't think the response result to be.



3.9 Using gRPC
---------------------------------------
Introduction to gRPC and Protobuf

What is gRPC?
A message passing technique developed by Google in 2015.
gRPC stands for g* Remote Procedure Calls where the g stands for something different in every release of gRPC. For example, the g in gRPC 1.12 stands for glorious.
Programming-language agnostic
Seeing greater traction and adoption in the industry.
Compared to REST, gRPC provides greater performance at the expense of less flexibility.
Clients that call gRPC can treat it as a method call in their own application by stubbing the gRPC service.
Does not require an HTTP library to make an API request because the application code can call a method that is "hooked up" to a gRPC service internally.
gRPC is Fast!
Leverages HTTP/2 for transporting messages
Transports binary data
Uses protocol buffers (protobufs) for efficiently transporting structured data
HTTP/2
gRPC takes advantage of the HTTP/2 protocol.
There are changes introduced in HTTP/2 that improve the overall security and performance of the web.
We need to acknowledge the fact that by using HTTP/2, gRPC can significantly improve its performance with regards to response sizes and overhead of connections.
For more details on HTTP/2, I encourage you to visit the Additional Reading section below.

Message Sizes
Messages are transmitted as binary data.
This reduces the overall size of the payload and thereby improving the request and response times.
Connections Overhead
Traditionally, an HTTP request could end up creating more HTTP requests that are blocking in nature.
HTTP/2 helps reduce this overhead and make more efficient use of resources by multiplexing its data with a unique connection between the client and server.
Protocol Buffers
A Protocol buffer, also known as a protobuf, is another way to serialize messages. We can think of it as an alternative to JSON or YAML with its set of tradeoffs.
gRPC uses protobufs to pass its messages.
Protobuf messages are designed to be backward and forwards compatible.
Clients that are processing a message expecting an older or newer version of the message will simply ignore fields they don't recognize.
Structured Data
Using protocol buffers helps us clearly define and lock down our interfaces to provide type safety and less confusion.
Analogy
We can think of using a dict versus using a class in Python:

The dict is flexible but doesn't have enforcement on what values go into it. A client reading a dict may run into `KeyErrorException'errors from trying to read bad data.
A class defines which fields are used and sets up a straightforward interface. dict 's are very flexible and allow us to be more efficient at the expense of safety.
A dict is similar to using REST while a class is similar to using gRPC.

Binary Data
Protobufs are designed to be serialized into binary blobs, making it very efficient to transport our data "over the wire" through a network.
Compared to human-readable formats like JSON: these binary messages can't be read without first being decoded and we can't simply craft a binary message in our text editors.
Message Size
Message size matters in response times for APIs.
A message that's 50 bytes will respond much faster than a message that is 50 Mb in size. In the context of an API that is processing thousands of requests per second, the effects of message size can add up!
Protobuf messages passed in gRPC are significantly smaller in size than message formats like JSON:

Binary encodings are efficient and have a small footprint.
JSON has a lot of brackets and syntax that increase the size of the payload.
Decoding
Since protobufs are a form of structured data, the binary data can be decoded very quickly. Compare this with a format like JSON, which is simply an unstructured string that needs to be parsed into some data structure before it can be properly consumed.
Protobuf Messages

When we create a protobuf message, we are defining the format of the message.

Protobuf vs. JSON
Protobuf messages define what an item must be. JSON defines what an item should be.

Protobuf - breaks if schema is modified and is strictly typed
JSON - schema can be modified and typing is not enforced
Protobuf message

message Item {
  string name = 1;
  string brand_name = 2;
  int32 id = 3;
  float weight = 4;
}
The message defines the fields for theItem field.

Each field has a type associated with it.
The integers at the end of each field are not values but are assignments used to declare field numbers. These are crucial in helping protobuf handle binary blobs of data.
Note that you may see some examples in other sources use required and optional for the fields in their messages. Those were removed in the proto3 version.

JSON message

{
 "id": <item_id: string>,
    "brand_name": <string>,
    "name": <string>,
    "weight": <float>,
}
Binary Data
Protobufs are designed to be serialized into binary blobs, making it very efficient to transport our data "over the wire" through a network.
Compared to human-readable formats like JSON: these binary messages can't be read without first being decoded and we can't simply craft a binary message in our text editors.
Message Size
Binary data also helps reduce the size of messages. Data is stored in a way that is efficient for machines to process but unreadable for humans.

Message size matters in response times for APIs.
A message that's 50 bytes will respond much faster than a message that is 50 Mb in size. In the context of an API that is processing thousands of requests per second, the effects of message size can add up!

Protobuf Service
Unlike REST, we also define how our API messages are used in gRPC.
Protobuf services define our input and outputs of our services.
Service ItemService {
    rpc Create(ItemMessage) returns (ItemMessage)
}
In the example above, we declare that an ItemService has a method that accepts an ItemMessage and returns an ItemMessage

Sets strict interface on how a user is expected to interact with the service.
No logic needs to be implemented; we simply define how a user will interact with ItemService
Using gRPC

By using binary data, Protobuf messages passed in gRPC are significantly smaller in size than message formats like JSON:

Binary encodings are efficient and have a small footprint.
JSON has a lot of brackets and syntax that increase the size of the payload.
Decoding
Since protobufs are a form of structured data, the binary data can be decoded very quickly. Compare this with a format like JSON, which is simply an unstructured string that needs to be parsed into some data structure before it can be properly consumed.
gRPC vs. REST Overview
REST has wider adoption
gRPC is more structured
gRPC is faster out-of-the-box
In general, gRPC provides more speed and structure at the expense of less flexibility and more overhead of setup.

Use Cases for gRPC
There are many uses cases for gRPC.

Need for Speed
gRPC boasts better performance than REST, but this doesn't mean that we should default to using gRPC for everything.
REST currently has significantly more adoption than gRPC, and REST can be designed to be very performant.
Microservices
Microservices communicate with one another via a network and rely on message passing.
Network calls inherently take more time to process than functionality contained in a single network like most monoliths.
For internal systems that dictate fast performance, gRPC may be used by modules in a microservice to pass messages with one another.
Mobile Devices
Mobile devices can integrate well with gRPC without an intermediary proxy to the backend service.
Applications can invoke function calls directly as if it were local code. To illustrate with Python, the method can accept objects instead of serializing and deserializing a dict object.

gRPC Protobuf Requirements
Basics
These the minimum requirements for a gRPC protobuf message:

Typing - type definition such as if a field is a string, float, etc
Field Name - the key for the value you are storing data
Order Number - used by gRPC for managing binary serialization
Some Other Features
These are a few features of protobufs that enrich our message definitions:

Enum - denotes what values a string can be
Nested Type - define a type as a user-defined type such as an enum
Default Value - set gRPC to set a default value when none is provided
To learn more about available features, I encourage you to reference the Proto3 Language Guide.

We've gone over how to create protobuf messages. We will learn about how to introduce them into our application code to build clients and servers in the next lesson.

New Terms
Term	Definition
gRPC	Programming-agnostic way of passing messages as protocol buffers to enforce a strict interface
HTTP/2	More secure and performant way of making HTTP requests that is backwards compatible
Protocol buffers	A way to serialize structured data optimizing simplicity and performance
Learn More About gRPC
While we went over some concepts on a higher level, the following are some resources if you would like to dive into more detail about them:

Protobuf
HTTP/2



3.10 Quizzes: Using gRPC
---------------------------------------
q1
Protocol Buffers (protobuf)
http/2
binary data
structured data

q2
gRPC requires fewer developer resources to implement
gRPC and REST both use JSON to structure messages
REST is often used over gRPC because it is more performant out-of-the-box



3.11 Exercise: Planning for gRPC
---------------------------------------
Using gRPC
News of our computer ordering service has made its way to other departments in the organization. After using the service to place multiple orders, some data scientists have decided that they want to perform analysis on the financial department's computer orders! We don't need to understand how their models work, but we need to set up a way to retrieve the data. Their team leverages gRPC for its strong performance and strict data structuring to run their models.

For your reference, the following is the sample protobuf message that was introduced in the lesson:

syntax = "proto3";


message Item {
  string name = 1;
  string brand_name = 2;
  int32 id = 3;
  float weight = 4;
}

Service ItemService {
    rpc Create(ItemMessage) returns (ItemMessage)
}

Exercise: Use Cases of gRPC
Plan for the gRPC service by creating the protobuf message and computer ordering service.

To customize the computer orders, we want to allow users to specify the equipment that they want on the computer. An order should also include the user who created the order, the status of the order, and the time an order was placed.

Using the proto3 syntax, create the message and services for our computer ordering application. You may find it useful to use your previous JSON solution as a starting point and reference the protobuf documentation.



3.12 Solution: Planning for gRPC
---------------------------------------
Simple Solution
From our previous exercise, we know that a possible way to structure an Order resource looks like this:

JSON
{
    "order_id": <order_id: str>,
    "created_by": <user_id: str>,
    "status": <status_enum: str>,
    "created_at": <isoformat_timestamp: str>,
    "equipment": [
        <equipment: str>
    ]
}

Protobuf Message - Simple Solution
message OrderMessage {
  string order_id = 1;
  string created_by = 2;
  string status = 3;
  string created_at = 4;
  repeated string equipment = 5;
}
We are essentially mapping the JSON message into a Protobuf message. This may seem a little trivial -- the only benefit we get is that the fields have enforced typing of strings.

With JSON, typing isn't enforced and we need application code to validate the type. For example, if we can pass order_id as an int instead of a string in JSON messages but protobuf messages will raise an error.

Service
Since our OrderMessage is used as both the request and response, our service can be easily defined as:

service OrderService {
    rpc Create(OrderMessage) returns (OrderMessage);
}
Create an Even More Amazing Protobuf Message

Protobuf Message - Better Solution
Valid Strings in JSON
When we look at the fields captured in our object, what exactly constitutes a valid status field? When implemented into REST, we often write application code to check this value in the JSON message to ensure that it is one of Queued, Processing, Completed, and Failed.

Valid Strings in Protobuf
We can leverage protobuf so that our messages have built-in validation and we don't have to write additional code to validate the messages. The following is an example of using enumerated values to build a strict, structured message that makes our messages easy to process.

Protobuf Message Example

message OrderMessage {
 enum Status {
    Queued = 0;
    Processing = 1;
    Completed = 2;
    Failed = 3;
  }

  enum Equipment {
    Keyboard = 0;
    Mouse = 1;
    Webcam = 2;
    Monitor = 3;
  }

  string id = 1;
  string created_by = 2;
  Status status = 3;
  string created_at = 4;
  repeated Equipment equipment = 5;
}

Instead of passing strings to the status and equipment, we enforce that only one of the Status and Equipment enum's are valid inputs.

Comparisons
Overall, protobuf messages are more strict and allow you to have built-in validations.

RESTful APIs using JSON are deliberately very flexible, and those who want to add more data validation into their applications rely on 3rd party libraries. For example, Python applications often use tools like marshmallow to validate data by performing validations, such as ensuring that the value in a field is a string.


q1
if you want to quickly prototype , json is very suitable. When speed matter, just use protobuf.

￼

3.13 Using Message Queues
---------------------------------------
Why Do We Need Message Queues?

Mailbox Analogy
Message queues are similar to handling mail delivery

A small business can answer the door to receive every piece of mail as it arrives.
As the business becomes larger, and mail volume grows, mail delivery becomes disruptive so the business can set up an unattended mailbox where the mail can be dropped off.
Over time, the business may need to set up multiple mailboxes to handle the volume of mail
At some point it becomes helpful to set up a Post Office box to receive all of the inbound mail and distribute the accumulated mail to various mailboxes by the company
Message Queues
Message queues improve performance, improve reliability, and enable decoupling of our systems

RabbitMQ can be helpful to set up a simple queue.
A distributed queue like Kafka may be needed for large volumes of data
When we can't handle the load of messages, or if we want to process our messages in batches instead of on-demand, or avoid losing messages during downtime, a message queue is a great solution.

Performance
A common source of latency in APIs is waiting for an API response. Queues allow us to do other things instead of idly waiting for a response from the server.

Synchronous Request
Usually, when we submit an HTTP request, it may take a few seconds for some backend logic to process everything.
While it's processing, we are idly waiting either for a result or for an HTTP timeout to bail us out of an irregularly long wait time. The property of waiting for a process to complete is synchronous.
Asynchronous Request
With an asynchronous request, we can make better use of our time by doing something else instead of waiting for the server to respond.
In practice, this means that we design an API endpoint that will acknowledge a request immediately but not return any desired data.
Reliability
A generic API has a lot of custom business functionality. There are many moving parts and it is designed to address business values.
A message queue is intentionally designed to do a few things very well: remain available to accept messages.
Using a queue, we can have our systems available for clients, even if other parts of the service may not be functioning.
Decoupling
Designing with queues helps provide us a guideline for how we want to create cleanly decoupled systems. While this is not absolute, if it makes sense to use a queue, there's a good chance that we have identified a part of our service that can be decoupled into its own service. Message queues and microservices go hand-in-hand!

New Terms
Term	Definition
Message Queue	Storing messages to set up performance, improve reliability, and enable decoupling of our systems
Synchronous	A blocking action that will wait for a process to finish before proceeding
Asynchronous	A non-blocking action that will continue while a process is still ongoing
Decoupled	Different systems that can be modified without affecting the other
Kafka	An open-source distributed message broker
RabbitMQ	An open-source message broker
Learn More About Message Queues
The following are some additional resources for learning about 3 types of popular queues: Kafka, RabbitMQ, and AWS SQS.

Kafka Use Cases
RabbitMQ
AWS SQS


3.14 Quizzes: Message Queues
---------------------------------------
q1
asynchronous
synchronous
reliability
decoupling
kafka

q2
A service periodically runs out of memory and fails during business hours with heavy traffic
A service runs once a night to process batched requests
A service produces a message that needs to be processed by multiple consumers



3.
---------------------------------------


